== Main Data Structures

Two essential DFLib classes are `Series` and `DataFrame`. `Series` is 1-dimensional array-like object, and `DataFrame`
is a 2-dimensional table-like object. Columns in a DataFrame are stored as Series.

Both DataFrame and Series are _immutable_, so all the operations on them return a new instance. Behind the scenes
shares as much data as possible between instances, so copying these objects does not cause significant performance
degradation, and in turn makes DFLib fully thread-safe, with concurrent operations possible on the same data structure.
Also immutability means that you can have a full snapshot of your data at each step of a transformation, simplifying
debugging and auditing of data pipelines.

=== Series

`Series` is the simplest of the two data structures. You can think of it as a wrapper around an array of values.
Series object is parameterized for the type of data that it holds. So there can be `Series<String>` or a
`Series<LocalDate>`, etc. You can use `Series` to model sequences of data (e.g. timestamps in a time series), etc.

`Series` can be created using static `forData` method on the `Series` interface:

[source,java,indent=0]
----
include::../../java/com/nhl/dflib/docs/SeriesExamples.java[tags=create]
----

----
a
bcd
...
g
4 elements
----
There is a whole category of "primitive" Series that are optimized for memory use and arithmetic operations performance.
There are Series for `int`, `double`, `long` and `boolean` values. E.g.:

[source,java,indent=0]
----
include::../../java/com/nhl/dflib/docs/SeriesExamples.java[tags=createInt]
----

While all of them can pose as "object" Series (e.g. `IntSeries` implements `Series<Integer>`), for efficiency you should
use primitive versions of each operation whenever possible. E.g. `concatInt` instead of just `concat`, etc.

`Series` object defines a number of useful data manipulation and transformation operations, that will be covered in the
following chapters. Also it is very important as a building block of DataFrame.

=== DataFrame

`DataFrame` is an in-memory table with rows and columns. Each column has a name, and is represented as a `Series` object.
DataFrame can contain columns of different kinds and is not parameterized for a single type. There is a special "builder"
API to create DataFrames from arrays, Streams, Collections, etc.

[source,java,indent=0]
----
include::../../java/com/nhl/dflib/docs/DataFrameExamples.java[tags=createFoldByRow]
----
<1> The builder starts by passing column names
<2> Passing a varargs array of values, that is folded to match the specified number of columns, row by row.

The resulting DataFrame looks like this:
----
name   age
------ ---
Joe    18
Andrus 45
Joan   32
3 rows x 2 columns
----

Instead of folding by rows, builder can fold the array column by column:
[source,java,indent=0]
----
include::../../java/com/nhl/dflib/docs/DataFrameExamples.java[tags=createFoldByColumn]
----
You can also create DataFrames from Collections and Streams (folded either by row or by column). Here is an example
of how to use Streams of primitive ints, creating a DataFrame made of memory-efficient `IntSeries` columns:
[source,java,indent=0]
----
include::../../java/com/nhl/dflib/docs/DataFrameExamples.java[tags=createFromIntStream]
----

----
col1 col2
---- ----
   0 5000
   1 5001
   2 5002
...
4997 9997
4998 9998
4999 9999
5000 rows x 2 columns
----

As we've mentioned, DataFrame columns are stored as Series, so another way to create a DataFrame is to pass
an array of Series:

[source,java,indent=0]
----
include::../../java/com/nhl/dflib/docs/DataFrameExamples.java[tags=createFromSeries]
----

Now that we've discussed how to create Series and DataFrames, next we'll talk about <<printers,printing their contents>>,
and then will continue to the chapters that describe data operations.